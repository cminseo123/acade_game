<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Real Ice Hockey</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { 
            font-family: Pretendard, sans-serif; 
            margin: 0; overflow: hidden;
            background: #a5f3fc; 
            touch-action: none; 
            user-select: none;
        }

        .ice-bg {
            position: absolute; inset: 0; z-index: -1;
            background: radial-gradient(circle at 50% 50%, #e0f7fa, #b3e5fc, #81d4fa);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.2);
        }
        
        canvas { display: block; width: 100vw; height: 100vh; cursor: none; }

        .score-board {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            font-size: 6rem; font-weight: 900;
            color: rgba(0,0,0,0.1); 
            display: flex; gap: 60px; pointer-events: none;
        }

        .goal-msg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem; font-weight: 900; color: #ff0055;
            text-shadow: 2px 2px 0 #fff;
            opacity: 0; transition: opacity 0.2s;
            z-index: 50; text-align: center; width: 100%;
            pointer-events: none;
        }
        .show-goal { opacity: 1; animation: pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes pop { 0% { transform: translate(-50%, -50%) scale(0.5); } 50% { transform: translate(-50%, -50%) scale(1.2); } 100% { transform: translate(-50%, -50%) scale(1); } }

        .close-btn {
            position: absolute; top: 20px; left: 20px;
            pointer-events: auto; z-index: 100;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(0,0,0,0.1); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            color: #333; border: 1px solid rgba(255,255,255,0.5);
            cursor: pointer; transition: all 0.2s;
        }
        .close-btn:active { transform: scale(0.9); }

        .guide-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(0,0,0,0.4); font-size: 0.9rem; font-weight: bold;
            text-align: center; width: 100%;
            animation: fadeOut 4s forwards; pointer-events: none;
        }
        @keyframes fadeOut { 0%, 80% { opacity: 1; } 100% { opacity: 0; } }

        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }
        .overlay.show { opacity: 1; pointer-events: auto; }
    </style>
</head>
<body>

    <div class="ice-bg"></div>

    <a href="index.html" class="close-btn">
        <i class="fa-solid fa-xmark text-xl"></i>
    </a>

    <div class="score-board">
        <span id="scoreTop" class="text-pink-500/50">0</span>
        <span class="text-black/10">-</span>
        <span id="scoreBottom" class="text-cyan-600/50">0</span>
    </div>

    <div id="goalMsg" class="goal-msg">GOAL!</div>
    <div class="guide-text">
        REAL ICE HOCKEY<br>
        3점 내기 한판 승부!
    </div>

    <div id="gameOverScreen" class="overlay">
        <div class="text-6xl mb-6 animate-bounce">❄️</div>
        <h2 id="winnerText" class="text-5xl font-black mb-2 text-white drop-shadow-lg text-center">WINNER!</h2>
        <p class="text-white/80 text-lg mb-10">빙판의 지배자!</p>
        <button onclick="restartGame()" class="px-10 py-4 bg-white text-black font-black rounded-full text-xl shadow-lg active:scale-95 transition hover:bg-gray-100">
            다시 하기 ↻
        </button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreTopEl = document.getElementById('scoreTop');
        const scoreBottomEl = document.getElementById('scoreBottom');
        const goalMsg = document.getElementById('goalMsg');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winnerText = document.getElementById('winnerText');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const FRICTION = 0.995; 
        const MAX_SPEED = 22;   
        
        const PADDLE_RADIUS = 40; 
        const PUCK_RADIUS = 22; 
        const GOAL_SIZE = 150; 
        const GOAL_DEPTH = 40; 
        const WIN_SCORE = 3; 
        const SUB_STEPS = 8; 

        let scoreTop = 0;
        let scoreBottom = 0;
        let isPaused = false;
        let particles = [];
        let scoringState = null; 
        let globalTime = 0; 

        let bgCanvas = document.createElement('canvas');
        bgCanvas.width = canvas.width;
        bgCanvas.height = canvas.height;
        let bgCtx = bgCanvas.getContext('2d');
        drawIceScratches(); 

        const puck = { x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0, radius: PUCK_RADIUS };
        
        const playerTop = { 
            x: canvas.width / 2, y: 120, targetX: canvas.width/2, targetY: 120,
            visualX: canvas.width / 2, visualY: 120,
            prevX: canvas.width / 2, prevY: 120,
            vx: 0, vy: 0,
            radius: PADDLE_RADIUS, 
            colorMain: '#ec4899', colorDark: '#be185d', colorLight: '#fbcfe8',
            isDragging: false, touchId: null,
            blinkTimer: 0, expression: 'normal' 
        };
        const playerBottom = { 
            x: canvas.width / 2, y: canvas.height - 120, targetX: canvas.width/2, targetY: canvas.height - 120,
            visualX: canvas.width / 2, visualY: canvas.height - 120,
            prevX: canvas.width / 2, prevY: canvas.height - 120,
            vx: 0, vy: 0,
            radius: PADDLE_RADIUS, 
            colorMain: '#06b6d4', colorDark: '#0891b2', colorLight: '#cffafe',
            isDragging: false, touchId: null,
            blinkTimer: 0, expression: 'normal'
        };

        class Particle {
            constructor(x, y, color, type = 'ice') {
                this.x = x; this.y = y;
                const speed = type === 'sweat' ? 5 : 8;
                this.vx = (Math.random() - 0.5) * speed;
                this.vy = (Math.random() - 0.5) * speed;
                this.life = 1.0; 
                this.color = color;
                this.size = Math.random() * 4 + 1;
                this.type = type;
            }
            update() { 
                this.x += this.vx; this.y += this.vy; 
                this.life -= 0.03; 
                if (this.type === 'sweat') this.vy += 0.5; 
                this.size *= 0.92; 
            }
            draw(ctx) { 
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color; 
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); 
                ctx.globalAlpha = 1.0; 
            }
        }
        function spawnParticles(x, y, color, count = 10, type = 'ice') { 
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color, type)); 
        }

        function drawIceScratches() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            bgCtx.lineWidth = 1;
            for(let i=0; i<100; i++) {
                bgCtx.beginPath();
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const len = Math.random() * 50 + 10;
                const ang = Math.random() * Math.PI * 2;
                bgCtx.moveTo(x, y);
                bgCtx.lineTo(x + Math.cos(ang)*len, y + Math.sin(ang)*len);
                bgCtx.stroke();
            }
        }

        function gameLoop() {
            if(!isPaused) {
                for(let i=0; i<SUB_STEPS; i++) {
                    updatePhysics(1 / SUB_STEPS);
                }
                updateVisuals();
                draw();
            }
            globalTime += 0.1;
            requestAnimationFrame(gameLoop);
        }

        function updatePhysics(dt) {
            if (isPaused) return;

            const moveFactor = 0.6;
            playerTop.prevX = playerTop.x; playerTop.prevY = playerTop.y;
            playerTop.x += (playerTop.targetX - playerTop.x) * moveFactor * dt * 5; 
            playerTop.y += (playerTop.targetY - playerTop.y) * moveFactor * dt * 5;
            playerTop.vx = (playerTop.x - playerTop.prevX) / dt;
            playerTop.vy = (playerTop.y - playerTop.prevY) / dt;

            playerBottom.prevX = playerBottom.x; playerBottom.prevY = playerBottom.y;
            playerBottom.x += (playerBottom.targetX - playerBottom.x) * moveFactor * dt * 5;
            playerBottom.y += (playerBottom.targetY - playerBottom.y) * moveFactor * dt * 5;
            playerBottom.vx = (playerBottom.x - playerBottom.prevX) / dt;
            playerBottom.vy = (playerBottom.y - playerBottom.prevY) / dt;

            // [골인 중일 때 강제 이동]
            if (scoringState === 'bottom') {
                puck.vy -= 0.5 * dt * 60; // 위로 빨려 들어감 (Top Goal)
                puck.vx *= 0.9; // 좌우 흔들림 감소
            } else if (scoringState === 'top') {
                puck.vy += 0.5 * dt * 60; // 아래로 빨려 들어감 (Bottom Goal)
                puck.vx *= 0.9;
            } else {
                // 평소 물리
                puck.x += puck.vx * dt;
                puck.y += puck.vy * dt;
                
                if (dt === 1/SUB_STEPS) { 
                     puck.vx *= Math.pow(FRICTION, dt);
                     puck.vy *= Math.pow(FRICTION, dt);
                }
            }
            
            // 공 위치 업데이트 (골인 중에도 적용)
            if (scoringState) {
                puck.x += puck.vx * dt;
                puck.y += puck.vy * dt;
            }

            const inGoalX = puck.x > canvas.width/2 - GOAL_SIZE/2 && puck.x < canvas.width/2 + GOAL_SIZE/2;

            // 벽 충돌 (골인 중이면 벽 무시)
            if (!scoringState) {
                if (puck.x - puck.radius < 0) { puck.x = puck.radius; puck.vx *= -0.8; }
                else if (puck.x + puck.radius > canvas.width) { puck.x = canvas.width - puck.radius; puck.vx *= -0.8; }

                if (puck.y - puck.radius < 0) {
                    if (inGoalX) { 
                        scoringState = 'bottom'; // Top Goal entered (Bottom Player scores)
                    } else { 
                        puck.y = puck.radius; puck.vy *= -0.8; 
                    }
                }
                else if (puck.y + puck.radius > canvas.height) {
                    if (inGoalX) { 
                        scoringState = 'top'; // Bottom Goal entered (Top Player scores)
                    } else { 
                        puck.y = canvas.height - puck.radius; puck.vy *= -0.8; 
                    }
                }
            }

            // 골인 확정 처리 (깊숙이 들어갔을 때)
            if (scoringState === 'bottom' && puck.y < -GOAL_DEPTH) { 
                score('bottom'); scoringState = null; return; 
            } 
            else if (scoringState === 'top' && puck.y > canvas.height + GOAL_DEPTH) { 
                score('top'); scoringState = null; return; 
            }

            // 패들 충돌
            if (!scoringState) {
                checkPaddleCollision(playerTop); 
                checkPaddleCollision(playerBottom);
            }

            const speed = Math.sqrt(puck.vx**2 + puck.vy**2);
            if (speed > MAX_SPEED) {
                puck.vx = (puck.vx / speed) * MAX_SPEED;
                puck.vy = (puck.vy / speed) * MAX_SPEED;
            }
        }

        function updateVisuals() {
            const speedTop = Math.sqrt(playerTop.vx**2 + playerTop.vy**2);
            if (speedTop > 20 && Math.random() < 0.3) spawnParticles(playerTop.visualX, playerTop.visualY - 30, '#a5f3fc', 1, 'sweat');
            const speedBottom = Math.sqrt(playerBottom.vx**2 + playerBottom.vy**2);
            if (speedBottom > 20 && Math.random() < 0.3) spawnParticles(playerBottom.visualX, playerBottom.visualY - 30, '#a5f3fc', 1, 'sweat');

            const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
            const smoothFactor = 0.3;
            playerTop.visualX = lerp(playerTop.visualX, playerTop.x, smoothFactor);
            playerTop.visualY = lerp(playerTop.visualY, playerTop.y, smoothFactor);
            playerBottom.visualX = lerp(playerBottom.visualX, playerBottom.x, smoothFactor);
            playerBottom.visualY = lerp(playerBottom.visualY, playerBottom.y, smoothFactor);

            particles.forEach((p, index) => { p.update(); if(p.life <= 0) particles.splice(index, 1); });
        }

        function checkPaddleCollision(p) {
            const dx = puck.x - p.x;
            const dy = puck.y - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const minDist = p.radius + puck.radius;

            if (dist < minDist) {
                const angle = Math.atan2(dy, dx);
                const overlap = minDist - dist;
                puck.x += Math.cos(angle) * overlap;
                puck.y += Math.sin(angle) * overlap;

                const impactPower = 1.3;
                puck.vx = (puck.vx * -0.5) + (p.vx * impactPower);
                puck.vy = (puck.vy * -0.5) + (p.vy * impactPower);
                
                spawnParticles(puck.x - Math.cos(angle)*puck.radius, puck.y - Math.sin(angle)*puck.radius, '#fff', 10, 'ice');
                if(navigator.vibrate) navigator.vibrate(20);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bgCanvas, 0, 0);

            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)'; 
            ctx.beginPath(); ctx.moveTo(0, canvas.height / 2); ctx.lineTo(canvas.width, canvas.height / 2); ctx.stroke();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.2)';
            ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2); ctx.stroke();

            draw3DGoal(canvas.width/2, 0, GOAL_SIZE, GOAL_DEPTH, '#ff4081', true); 
            draw3DGoal(canvas.width/2, canvas.height, GOAL_SIZE, GOAL_DEPTH, '#00bcd4', false); 

            particles.forEach(p => p.draw(ctx));
            
            drawCuteCharacter(playerTop, true);
            drawCuteCharacter(playerBottom, false);

            draw3DPuckInGoal();
        }

        function drawCuteCharacter(p, isTop) {
            if (p.blinkTimer > 0) p.blinkTimer--;
            else if (Math.random() < 0.01) p.blinkTimer = 10;

            const x = p.visualX; const y = p.visualY;
            const tiltX = (p.x - p.prevX) * 2; 
            
            ctx.save();
            ctx.translate(x, y);
            if (isTop) ctx.rotate(Math.PI); 

            const legMove = (Math.abs(p.vx)>0.5 || Math.abs(p.vy)>0.5) ? Math.sin(globalTime * 8) * 8 : Math.sin(globalTime * 2) * 5;
            ctx.fillStyle = p.colorDark;
            ctx.beginPath(); ctx.arc(-25 + tiltX*0.2, 20 + legMove, 12, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(25 + tiltX*0.2, 20 - legMove, 12, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = 'rgba(0,0,0,0.2)'; 
            ctx.beginPath(); ctx.ellipse(5, 15, p.radius, p.radius*0.8, 0, 0, Math.PI*2); ctx.fill();

            ctx.rotate(tiltX * 0.03); 
            let grad = ctx.createRadialGradient(-10, -10, 5, 0, 0, p.radius);
            grad.addColorStop(0, p.colorLight); grad.addColorStop(0.3, p.colorMain); grad.addColorStop(1, p.colorDark);
            ctx.fillStyle = grad;
            
            const stretchX = 1 + Math.abs(p.vx)*0.01; const stretchY = 1 - Math.abs(p.vx)*0.01;
            ctx.scale(stretchX, stretchY);
            ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI*2); ctx.fill();

            const eyeOffsetX = Math.max(-8, Math.min(8, p.vx));
            const eyeOffsetY = Math.max(-8, Math.min(8, p.vy));
            ctx.lineWidth = 3; ctx.lineCap = 'round';

            if (p.expression === 'win') {
                ctx.strokeStyle = '#222';
                ctx.beginPath(); ctx.arc(-15, -10, 8, Math.PI*0.8, Math.PI*2.2); ctx.stroke(); 
                ctx.beginPath(); ctx.arc(15, -10, 8, Math.PI*0.8, Math.PI*2.2); ctx.stroke();
                ctx.fillStyle = '#ff5252'; ctx.beginPath(); ctx.arc(0, 10, 10, 0, Math.PI); ctx.fill(); 
                ctx.beginPath(); ctx.arc(Math.sin(globalTime*0.5)*5, 18, 6, 0, Math.PI); ctx.fill(); 
            } else if (p.expression === 'lose') {
                ctx.strokeStyle = '#222';
                ctx.beginPath(); ctx.moveTo(-20, -12); ctx.lineTo(-8, -12); ctx.moveTo(-14, -12); ctx.lineTo(-14, -4); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(8, -12); ctx.lineTo(20, -12); ctx.moveTo(14, -12); ctx.lineTo(14, -4); ctx.stroke();
                ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(-14, 0 + (globalTime%10)*2, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(14, 5 + (globalTime%10)*2, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(-10, 15); for(let i=0; i<20; i+=4) ctx.lineTo(-10+i, 15 + Math.sin(i*2 + globalTime*2)*2); ctx.stroke();
            } else {
                if (p.blinkTimer > 0) {
                    ctx.strokeStyle = '#222'; ctx.beginPath(); ctx.moveTo(-18, -5); ctx.lineTo(-6, -5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(6, -5); ctx.lineTo(18, -5); ctx.stroke();
                } else {
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-12 + eyeOffsetX, -10 + eyeOffsetY, 10, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(12 + eyeOffsetX, -10 + eyeOffsetY, 10, 0, Math.PI*2); ctx.fill(); 
                    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-12 + eyeOffsetX*1.2, -10 + eyeOffsetY*1.2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(12 + eyeOffsetX*1.2, -10 + eyeOffsetY*1.2, 4, 0, Math.PI*2); ctx.fill(); 
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(0 + eyeOffsetX*0.5, 5 + eyeOffsetY*0.5, 5, 0, Math.PI, false); ctx.stroke();
            }

            ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; 
            ctx.beginPath(); ctx.arc(0, -p.radius + 15, 25, Math.PI, 0); ctx.stroke(); 

            ctx.restore();
        }

        function draw3DGoal(x, y, width, depth, color, isTop) {
            const halfW = width / 2; const yEnd = isTop ? y - depth : y + depth; const yEdge = isTop ? y : y;
            const grad = ctx.createLinearGradient(x, y, x, yEnd);
            grad.addColorStop(0, isTop ? 'rgba(0,0,0,0.1)' : color + '33'); grad.addColorStop(1, isTop ? color + '33' : 'rgba(0,0,0,0.5)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.moveTo(x - halfW, yEdge); ctx.lineTo(x + halfW, yEdge); ctx.lineTo(x + halfW * 0.8, yEnd); ctx.lineTo(x - halfW * 0.8, yEnd); ctx.closePath(); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.moveTo(x - halfW, yEdge); ctx.lineTo(x - halfW * 0.8, yEnd); ctx.lineTo(x - halfW * 0.8, yEnd + (isTop?5:-5)); ctx.lineTo(x - halfW, yEdge + (isTop?5:-5)); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x + halfW, yEdge); ctx.lineTo(x + halfW * 0.8, yEnd); ctx.lineTo(x + halfW * 0.8, yEnd + (isTop?5:-5)); ctx.lineTo(x + halfW, yEdge + (isTop?5:-5)); ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(x - halfW - 5, yEdge); ctx.lineTo(x + halfW + 5, yEdge); ctx.stroke();
        }

        function draw3DPuckInGoal() {
            let alpha = 1.0; let darken = 0;
            if (puck.y < 0) { const depthRatio = Math.min(Math.abs(puck.y) / GOAL_DEPTH, 1); alpha = 1 - depthRatio; darken = depthRatio * 150; } 
            else if (puck.y > canvas.height) { const depthRatio = Math.min((puck.y - canvas.height) / GOAL_DEPTH, 1); alpha = 1 - depthRatio; darken = depthRatio * 150; }
            if (alpha <= 0) return;
            ctx.save(); ctx.globalAlpha = alpha;
            const baseColorVal = Math.max(50 - darken, 10);
            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.arc(puck.x + 3, puck.y + 5, puck.radius, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI*2); ctx.fill(); // 검은색 퍽
            ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(puck.x, puck.y - 2, puck.radius * 0.8, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        function score(winner) {
            // [버그 수정] 중복 득점 방지
            if (isPaused) return;

            if(winner === 'top') scoreTop++; else scoreBottom++;
            scoreTopEl.innerText = scoreTop; scoreBottomEl.innerText = scoreBottom;

            if (winner === 'top') { playerTop.expression = 'win'; playerBottom.expression = 'lose'; } 
            else { playerTop.expression = 'lose'; playerBottom.expression = 'win'; }

            isPaused = true; 

            if (scoreTop >= WIN_SCORE || scoreBottom >= WIN_SCORE) { endGame(winner); return; }

            goalMsg.classList.add('show-goal'); 
            if(navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 150]);
            
            setTimeout(() => { 
                goalMsg.classList.remove('show-goal'); 
                playerTop.expression = 'normal'; playerBottom.expression = 'normal'; 
                resetPuck(); isPaused = false; 
            }, 2000); 
        }

        function endGame(winner) {
            const name = winner === 'top' ? 'PINK' : 'BLUE';
            const colorClass = winner === 'top' ? 'text-pink-400' : 'text-cyan-400';
            winnerText.innerText = `${name} WINS!`;
            winnerText.className = `text-5xl font-black mb-2 drop-shadow-lg text-center ${colorClass}`;
            gameOverScreen.classList.add('show');
        }

        function restartGame() {
            scoreTop = 0; scoreBottom = 0;
            scoreTopEl.innerText = 0; scoreBottomEl.innerText = 0;
            gameOverScreen.classList.remove('show');
            playerTop.expression = 'normal'; playerBottom.expression = 'normal';
            resetPuck(); isPaused = false; gameLoop();
        }

        function resetPuck() {
            puck.x = canvas.width / 2; puck.y = canvas.height / 2; puck.vx = 0; puck.vy = 0;
            playerTop.targetX = canvas.width / 2; playerTop.targetY = 120;
            playerBottom.targetX = canvas.width / 2; playerBottom.targetY = canvas.height - 120;
            scoringState = null;
        }

        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
        canvas.addEventListener('touchend', endTouch);

        function handleTouch(e) {
            e.preventDefault();
            for (let i = 0; i < e.touches.length; i++) {
                const t = e.touches[i];
                if (t.clientY < canvas.height / 2) updatePaddleTarget(playerTop, t.clientX, t.clientY, t.identifier);
                else updatePaddleTarget(playerBottom, t.clientX, t.clientY, t.identifier);
            }
        }

        function updatePaddleTarget(p, tx, ty, id) {
            if (!p.isDragging || p.touchId === id) {
                p.touchId = id; p.isDragging = true;
                p.targetX = tx; 
                if (p === playerTop) p.targetY = Math.min(ty, canvas.height/2 - p.radius);
                else p.targetY = Math.max(ty, canvas.height/2 + p.radius);
            }
        }

        function endTouch(e) {
            const activeIds = Array.from(e.touches).map(t => t.identifier);
            if (!activeIds.includes(playerTop.touchId)) playerTop.isDragging = false;
            if (!activeIds.includes(playerBottom.touchId)) playerBottom.isDragging = false;
        }

        canvas.addEventListener('mousemove', (e) => {
            playerBottom.targetX = e.clientX; 
            playerBottom.targetY = Math.max(e.clientY, canvas.height / 2 + playerBottom.radius);
            playerBottom.isDragging = true;
        });
        window.addEventListener('keydown', (e) => {
            const speed = 25;
            if (e.key === 'a') playerTop.targetX -= speed; if (e.key === 'd') playerTop.targetX += speed;
            if (e.key === 'w') playerTop.targetY -= speed; if (e.key === 's') playerTop.targetY += speed;
        });

        window.addEventListener('resize', () => { 
            canvas.width = window.innerWidth; canvas.height = window.innerHeight; 
            bgCanvas.width = canvas.width; bgCanvas.height = canvas.height; 
            drawIceScratches(); resetPuck(); 
        });

        gameLoop();
    </script>
</body>
</html>
